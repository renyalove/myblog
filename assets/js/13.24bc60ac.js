(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{496:function(t,e,s){"use strict";s.r(e);var a=s(4),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"_1、如何在es5环境下实现let"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、如何在es5环境下实现let"}},[t._v("#")]),t._v(" 1、如何在ES5环境下实现let")]),t._v(" "),s("p",[t._v("babel在let定义的变量前加了道下划线，避免在块级作用域外访问到该变量，除了对变量名的转换，我们也可以通过自执行函数来模拟块级用域。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function _const(key, value) {    \n    const desc = {        \n        value,        \n        writable: false    \n    }    \n    Object.defineProperty(window, key, desc)\n}\n    \n_const('obj', {a: 1})   //定义obj\nobj.b = 2               //可以正常给obj的属性赋值\nobj = {}                //抛出错误，提示对象read-only(严格模式)，非严格模式不会改变obj的值，也不会报错\n")])])]),s("p",[t._v("bind 函数的实现原理https://juejin.im/post/5b3c3377f265da0f8f20131f")]),t._v(" "),s("p",[t._v("虽然为了解决构造函数被执行两次的问题, 我们将"),s("code",[t._v("指向父类实例")]),t._v("改为"),s("code",[t._v("指向父类原型")]),t._v(", 减去一次构造函数的执行。但是这时为子类添加原型方法，会影响到父类的原型。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Sub.prototype = new Super()")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Sub")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Super")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype\n")])])]),s("p",[t._v("http://hope.dev.corp.qihoo.net:8090/download/attachments/28347924/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.png?version=1&modificationDate=1586328642000&api=v2")])])}),[],!1,null,null,null);e.default=n.exports}}]);